经过两个月的面试，还是积累了比较多的面试经验，面试的时候会问很多基础的东西，然而这些往往是平时容易忽略的知识。现在我将这两个月准备的内容以及面试中常问的知识点都整理一下写成博客，方便大家也方便自己以后复习巩固，有的回答不一定标准，如果发现问题欢迎联系我进行修正。今天的内容是计算机网络部分。

# 1.OSI开放式互联参考模型有哪些组成？
## 第1层：物理层
机械、电子、定时接口通信信道上的原始比特流传输，将010101等比特数据转换为电流强弱来进行传输（数模转换与模数转换）

网卡
## 第2层：数据链路层
物理寻址，同时将原始比特流转换为逻辑传输线路。这一层提供错误检测与纠正，以确保数据传输的可靠性。

交换机
## 第3层：网络层
将网络地址翻译成对应的物理地址。控制子网的运行，入逻辑编制、分组传输、路由选择。

协议：TCP/IP

路由器
## 第4层：传输层
传输层解决了传输质量的问题，控制流量、数据包分割等。

协议：TCP、UDP

## 第5层：会话层
不同机器上的用户之间建立及管理会话。

## 第6层：表示层
解决不同系统语法通信的问题，加解密、转换翻译、压缩解压缩。

## 第7层：应用层

协议：HTTP

# 2.TCP/IP模型有哪些组成？
该模型将OSI中的应用层、表示层、会话层归并到应用层，数据链路层、物理层归并到链路层。

先自上而下，后自下而上处理数据头部。

![](https://vr360-beifengtz.oss-cn-beijing.aliyuncs.com/beifeng-blog/article/java%E9%9D%A2%E7%BB%8F/%E8%AE%A1%E7%BD%91/1515072164471800.png)

# 3.什么是TCP协议？
TCP是网络传输层协议，是一种面向连接的、可靠传输的、基于字节流的传输协议。

# 4.什么是UDP协议？
UDP也是网络传输层协议，是一种无连接的传输协议，提供面向事务的简单不可靠信息传送服务，传输速率相对较快，但不能保证数据可靠性。

# 5.TCP报文头有哪些组成？
包含源端口和目的端口、Sequence Number（分段标识符）、Acknowledgement Number（确认收到的标识符）

TCP Flags：
> * URG：紧急指针标志
> * ACK：确认序号标志
> * PSH：push标志
> * RST：重置连接标志
> * SYN：同步序号，用于建立连接过程
> * FIN：finish标志，用于释放链接

> 进程间通信必须有唯一标识符，在同一计算机中用PID标识，在不同计算机中用端口标识。

![](https://vr360-beifengtz.oss-cn-beijing.aliyuncs.com/beifeng-blog/article/java%E9%9D%A2%E7%BB%8F/%E8%AE%A1%E7%BD%91/201708240001.jpg)

# 6.UDP报文有哪些组成？
源端口号、目的端口号、目的地址、数据报长度、奇偶校验和、数据等

![](https://vr360-beifengtz.oss-cn-beijing.aliyuncs.com/beifeng-blog/article/java%E9%9D%A2%E7%BB%8F/%E8%AE%A1%E7%BD%91/20190420201656.jpg)

# 7.讲一讲TCP的三次握手？
握手是为了建立连接（为了初始化Sequence Number），避免传输的数据包乱序问题，握手成功之后会建立一个全双工通信通道。

* 第一次握手：客户端主动打开请求服务端，服务端被动打开监听LISTEN，客户端进入SYN_SEND状态，等待服务器确认；
* 第二次握手：服务端收到SYN包，回应客户端，如果同意连接就发送ACK确认信息，服务器进入SYN_RECV状态；
* 第三次握手：客户端收到确认信息，向服务器发送ACK确认信息，客户端进入可接受数据状态，服务器收到确认信息后也进入可接受数据状态（ESTABLISHED）。

![](https://vr360-beifengtz.oss-cn-beijing.aliyuncs.com/beifeng-blog/article/java%E9%9D%A2%E7%BB%8F/%E8%AE%A1%E7%BD%91/20190420195040.jpg)

# 8.讲一讲三次握手中SYN Flood隐患以及其解决措施
SYN Flood问题起因：
* Server收到Client的SYN，回复SYN-ACK的时候未收到ACK确认
* Server不断重试直至超时，Linux默认等待63秒（1 + 2 + 4 + 8 + 16 + 32）才断开连接

SYN Flood隐患：恶意程序向服务器发送SYN数据报，然后下线，造成服务器要等63秒才能断开连接，攻击者就可以将服务器的SYN队列耗尽，让正常的连接无法进行。

针对SYN Flood的防护措施
* SYN队列满后，通过tcp_syncookies参数会发SYN Cookie
* 若为正常连接则Client会回发SYN Cookie，直接建立连接

# 9.TCP的保活机制。

* 想对方发送保活探测报文，如果未收到响应则继续发送
* 尝试次数达到保活探测数之后，连接将会中断

# 10.为什么需要第三次握手?两次不可以吗？
不可以，三次握手是为了防止已失效的链接请求报文突然又传送到了服务端而产生错误。

> 客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。

# 11.讲一讲TCP的四次挥手

* 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态；
* 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态；
* 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Sever进入LAST_ACK状态；
* 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

![](https://vr360-beifengtz.oss-cn-beijing.aliyuncs.com/beifeng-blog/article/java%E9%9D%A2%E7%BB%8F/%E8%AE%A1%E7%BD%91/20190420200101.jpg)

# 12.为什么需要四次挥手？
因为TCP是全双工，发送方和接收方都需要FIN报文和ACK报文

# 13.四次挥手中为什么会有TIME_WAIT状态
* 确保有足够的时间让对方收到ACK包
* 避免新旧连接混淆

# 14.什么情况下服务器会出现大量CLOSE_WAIT状态？
当很多Client大量请求然后关闭Socket连接，服务器方忙于读或写，没有及时关闭连接。

服务器一旦达到CLOSE_WAIT上限就会抛出*too many open files*异常，甚至有可能造成服务器崩溃。

# 15.TCP的特点
* 面向连接
* 仅支持单播传输，每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播（multicast）和广播（broadcast）传输方式。
* 传输单位为数据段，TCP仍采用传统的“数据段”作为数据传输单元。由于数据段大小受应用层传送的报文大小和所途经网络中MTU（Maximum Transmission Unit）值大小决定，所以每次发送的TCP数据段大小是不固定的。在一个具体的网络中，有一个MSS（Maximum Segment Size，最大数据段大小），最小的数据段可能仅有21字节（其中20字节属于TCP数据段头部，数据部分仅1字节）。
* 支持全双工传输。
* 基于字节流的。
* 通过超时重传、重排序等机制保证数据可靠性。
# 16.UDP的特点
* 面向非连接。
* 不维护连接状态，支持同时向多客户端发送消息。
* 数据包报头小（8字节），开销小。
* 吞吐量仅受限于数据生成速率、传输速率及机器性能。
* 不保证可靠交付，不需要维护复杂的连接状态。
* 面向报文，不对应用程序提交的报文进行拆分或者合并。

# 17.TCP协议如何来保证传输的可靠性
* **数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；

* **对失序数据包重排序**：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；

* **丢弃重复数据**：对于重复数据，能够丢弃重复数据；

* **应答机制**：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；

* **超时重发**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；

* **流量控制**：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

# 18.解释一下什么是RTT和RTO
* RTT：发送一个数据包到收到对应的ACK所花费的时间
* RTO：重传时间间隔，根据RTT计算而来，经过RTO未收到对方的回应将重新发送该数据包。

# 19.TCP滑动窗口的作用
* 保证TCP的可靠性
* 保证TCP的流控特性

# 20.解释一下TCP中的滑动窗口协议
> 窗口滑动协议是TCP使用的一种流量控制方法。该协议允许发送方在停止并等待接收确认报文前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。只有在接收窗口向前滑动时（与此同时也发送了确认），发送窗口才有可能向前滑动。

在TCP报文头中的window字段用于接收方通知发送方还有多少缓存区可以接收数据，避免过多数据发送到接收方，造成接收方来不及处理甚至缓存区崩溃。

TCP中窗口大小是指tcp协议一次传输多少个数据。因为TCP是一个面向连接的可靠的传输协议，既然是可靠的就需要传输的数据进行确认。TCP窗口机制有两种，一种是固定窗口大小，另一种是滑动窗口。数据在传输时，TCP会对所有数据进行编号，发送方在发送过程中始终保持着一个窗口，只有落在发送窗口内的数据帧才允许被发送；同时接收方也始终保持着一个接收窗口，只有落在窗口内的数据才会被接收。这样通过改变发送窗口和接收窗口的大小就可以实现流量控制。


窗口计算过程原理图如下图所示，其各个指针含义：
* LastByteAcked：最后接收方收到并且发送方收到ack的数据位置
* LastByteSent：最后已发送数据的位置，已经发送出去但是未收到ack回应
* LastByteWritten：上层应用最后已写完的位置，即当前程序已经准备好的要发送的数据段位置
* LastByteRead：上层应用已经读完的数据位置，即已收到并且已经处理已经给发送方回执的数据位置
* NextByteExpected：收到并且正在处理的数据位置
* LastByteRcvd：已收到的最后一个字节的位置
![](https://vr360-beifengtz.oss-cn-beijing.aliyuncs.com/beifeng-blog/article/java%E9%9D%A2%E7%BB%8F/%E8%AE%A1%E7%BD%91/20190420203836.jpg)

发送方窗口：

![](https://vr360-beifengtz.oss-cn-beijing.aliyuncs.com/beifeng-blog/article/java%E9%9D%A2%E7%BB%8F/%E8%AE%A1%E7%BD%91/20190420205129.jpg)

接收方窗口：

![](https://vr360-beifengtz.oss-cn-beijing.aliyuncs.com/beifeng-blog/article/java%E9%9D%A2%E7%BB%8F/%E8%AE%A1%E7%BD%91/20190420205245.jpg)

# 21.什么情况会造成流量控制的死锁？如何避免死锁发生？
当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。

为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。

# 22.拥塞控制和流量控制的区别
* **拥塞控制**：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（1）、慢开始、拥塞避免，（2）、快重传、快恢复。
* **流量控制**：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。

# 23.在浏览器地址栏输入一个地址，按下回车之后经历的流程
1. DNS解析。逐层查询url的DNS缓存，解析出url域名所对应的ip地址，其顺序是：浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存；
2. TCP链接。根据ip地址简历TCP链接，三次握手；
3. 发送HTTP请求；
4. 服务器处理请求并返回HTTP报文；
5. 浏览器收到服务器发送的html文件并渲染到窗口；
6. 释放TCP连接，四次挥手。

# 24.HTTP状态码
* **1XX**：指示信息——表示请求已接收，继续处理
* **2XX**：成功——表示请求已经被成功接收、理解、处理
* **3XX**：重定向——要完成请求必须进行更进一步的操作
* **4XX**：客户端错误——请求有语法错误或请求无法实现
* **5XX**：服务器端错误——服务器未能实现合法的请求

# 25.解释一下HTTP 1.0、1.1、2.0各版本的区别
HTTP1.0不支持长连接，1.1以后支持长连接，从头部Keep-Alive可以看到。

HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求

HTTP 1.1则支持持久连接Persistent Connection, 并且默认使用persistent  connection. 在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如HTTP1.0没有host的字段).


HTTP2.0多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；支持request多路复用；新的二进制格式压缩头部

# 26.GET请求和POST请求的区别
之前有写过这个问题的博客，见我另一篇博客：[HTTP中GET与POST的区别](http://blog.beifengtz.com/article/43)

# 27.什么是SSL？
SSL全名Security Sockets Layer，即安全套接层，它是为网络通信提供安全及数据完整性的一种安全协议，是操作系统对外的API，SSL3.0后更名为TLS。它采用身份验证和数据加密保证网络通信的安全和数据的完整性。

# 28.SSL使用的加密算法有哪些？
* 对称加密：加密和解密使用同一个秘钥；
* 非对称加密：加密和解密的秘钥不相同，即公钥和私钥；
* 哈希算法：将任意长度的信息转换为固定长度的值，不可逆；
* 数字签名：保证某个消息或文件是某人发出或认同的。

# 29.简述一下HTTPS协议的数据传输流程
1. 浏览器将支持的加密算法信息发送给服务器
2. 服务器选择一套浏览器支持的加密算法，将验证身份的信息以证书的形式回发给浏览器
3. 浏览收到证书验证其合法性，并结合证书公钥加密信息发送给服务器
4. 服务器使用私钥解密信息，验证哈希，加密相应消息回发浏览器
5. 浏览器解密相应消息，并对消息进行验证。

# 30.HTTP和HTTPS有什么区别？
* HTTPS需要CA机构申请证书，HTTP不需要
* 默认端口不同，HTTP是80端口，HTTPS是443端口
* HTTPS是密文传输，HTTP是明文传输，HTTPS安全性更高
* HTTP比HTTPS少了身份验证和数据加密的过程，因此HTTP传输效率更高

# 31.什么是Socket？
socket是TCP/IP协议的抽象，是操作系统对外开放的接口

![](https://vr360-beifengtz.oss-cn-beijing.aliyuncs.com/beifeng-blog/article/java%E9%9D%A2%E7%BB%8F/%E8%AE%A1%E7%BD%91/733402-20160106212015200-534370991.png)

# 32.简述一下socket通信流程
见下图：

![](https://vr360-beifengtz.oss-cn-beijing.aliyuncs.com/beifeng-blog/article/java%E9%9D%A2%E7%BB%8F/%E8%AE%A1%E7%BD%91/20190420213058.jpg)

# 33.请使用java编写一个基于TCP通信的程序
见我之前的博客：[Java网络编程实现](http://blog.beifengtz.com/article/37)

# 34.请使用java编写一个基于UDP通信的程序
见我之前的博客：[Java实现UDP通信](http://blog.beifengtz.com/article/40)